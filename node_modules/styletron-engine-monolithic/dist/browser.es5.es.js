import { prefix } from 'inline-style-prefixer';

/* eslint-env browser */

/*
pretty much vendored @emotion/sheet
Based off glamor's StyleSheet, thanks Sunil ❤️
high performance StyleSheet for css-in-js systems
- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance
// usage
import { StyleSheet } from '@emotion/sheet'
let styleSheet = new StyleSheet({ container: document.head })
styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet
styleSheet.flush()
- empties the stylesheet of all its contents
*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement("style");

  if (typeof options.nonce !== "undefined") {
    tag.setAttribute("nonce", options.nonce);
  }

  tag.appendChild(document.createTextNode(""));
  return tag;
}

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(options) {
    this.isSpeedy = typeof options.speedy === "undefined" ? !(process.env.NODE_ENV !== "production") : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.container = options.container;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.insert = function insert(rules) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      var _tag = createStyleElement(this);

      var before;

      if (this.tags.length === 0) {
        before = this.before;
      } else {
        before = this.tags[this.tags.length - 1].nextSibling;
      }

      this.container.insertBefore(_tag, before);
      this.tags.push(_tag);
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      rules.forEach(function (rule) {
        try {
          // this is the ultrafast version, works across browsers
          // the big drawback is that the css won't be editable in devtools
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
          if (process.env.NODE_ENV !== "production") {
            // eslint-disable-next-line no-console
            console.warn("There was a problem inserting the following rule: \"" + rule + "\"", e);
          }
        }
      });
    } else {
      tag.appendChild(document.createTextNode(rules.join("")));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();

var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};
function hyphenateStyleName(prop) {
  return prop in cache ? cache[prop] : cache[prop] = prop.replace(uppercasePattern, "-$&").toLowerCase().replace(msPattern, "-ms-");
}

/**
 * Adapted from https://github.com/gilmoreorless/css-shorthand-properties
 */
var shorthandMap = {
  // CSS 2.1: https://www.w3.org/TR/CSS2/propidx.html
  "list-style": ["list-style-type", "list-style-position", "list-style-image"],
  margin: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
  outline: ["outline-width", "outline-style", "outline-color"],
  padding: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
  // CSS Backgrounds and Borders Module Level 3: https://www.w3.org/TR/css3-background/
  background: ["background-image", "background-position", "background-size", "background-repeat", "background-origin", "background-clip", "background-attachment", "background-color"],
  border: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-color"],
  "border-color": ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"],
  "border-style": ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"],
  "border-width": ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
  "border-top": ["border-top-width", "border-top-style", "border-top-color"],
  "border-right": ["border-right-width", "border-right-style", "border-right-color"],
  "border-bottom": ["border-bottom-width", "border-bottom-style", "border-bottom-color"],
  "border-left": ["border-left-width", "border-left-style", "border-left-color"],
  "border-radius": ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"],
  "border-image": ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
  // CSS Fonts Module Level 3: https://www.w3.org/TR/css3-fonts/
  font: ["font-style", "font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian", "font-variant", "font-weight", "font-stretch", "font-size", "line-height", "font-family"],
  "font-variant": ["font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian"],
  // CSS Flexible Box Layout Module Level 1: https://www.w3.org/TR/css3-flexbox-1/
  flex: ["flex-grow", "flex-shrink", "flex-basis"],
  "flex-flow": ["flex-direction", "flex-wrap"],
  // CSS Grid Layout Module Level 1: https://www.w3.org/TR/css-grid-1/
  grid: ["grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow"],
  "grid-template": ["grid-template-rows", "grid-template-columns", "grid-template-areas"],
  "grid-row": ["grid-row-start", "grid-row-end"],
  "grid-column": ["grid-column-start", "grid-column-end"],
  "grid-area": ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end"],
  "grid-gap": ["grid-row-gap", "grid-column-gap"],
  // CSS Masking Module Level 1: https://www.w3.org/TR/css-masking/
  mask: ["mask-image", "mask-mode", "mask-position", "mask-size", "mask-repeat", "mask-origin", "mask-clip"],
  "mask-border": ["mask-border-source", "mask-border-slice", "mask-border-width", "mask-border-outset", "mask-border-repeat", "mask-border-mode"],
  // CSS Multi-column Layout Module: https://www.w3.org/TR/css3-multicol/
  columns: ["column-width", "column-count"],
  "column-rule": ["column-rule-width", "column-rule-style", "column-rule-color"],
  // CSS Scroll Snap Module Level 1: https://www.w3.org/TR/css-scroll-snap-1/
  "scroll-padding": ["scroll-padding-top", "scroll-padding-right", "scroll-padding-bottom", "scroll-padding-left"],
  "scroll-padding-block": ["scroll-padding-block-start", "scroll-padding-block-end"],
  "scroll-padding-inline": ["scroll-padding-inline-start", "scroll-padding-inline-end"],
  "scroll-snap-margin": ["scroll-snap-margin-top", "scroll-snap-margin-right", "scroll-snap-margin-bottom", "scroll-snap-margin-left"],
  "scroll-snap-margin-block": ["scroll-snap-margin-block-start", "scroll-snap-margin-block-end"],
  "scroll-snap-margin-inline": ["scroll-snap-margin-inline-start", "scroll-snap-margin-inline-end"],
  // CSS Speech Module: https://www.w3.org/TR/css3-speech/
  cue: ["cue-before", "cue-after"],
  pause: ["pause-before", "pause-after"],
  rest: ["rest-before", "rest-after"],
  // CSS Text Decoration Module Level 3: https://www.w3.org/TR/css-text-decor-3/
  "text-decoration": ["text-decoration-line", "text-decoration-style", "text-decoration-color"],
  "text-emphasis": ["text-emphasis-style", "text-emphasis-color"],
  // CSS Animations (WD): https://www.w3.org/TR/css3-animations
  animation: ["animation-name", "animation-duration", "animation-timing-function", "animation-delay", "animation-iteration-count", "animation-direction", "animation-fill-mode", "animation-play-state"],
  // CSS Transitions (WD): https://www.w3.org/TR/css3-transitions/
  transition: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"]
};
function validateNoMixedHand(style) {
  var hyphenatedProperties = Object.keys(style).reduce(function (acc, property) {
    acc[hyphenateStyleName(property)] = property;
    return acc;
  }, {});
  var mixed = [];

  for (var property in hyphenatedProperties) {
    if (property in shorthandMap) {
      for (var _iterator = shorthandMap[property], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _longhand = _ref;

        if (_longhand in hyphenatedProperties) {
          var long = hyphenatedProperties[_longhand];
          var short = hyphenatedProperties[property];
          mixed.push({
            shorthand: {
              property: short,
              value: style[short]
            },
            longhand: {
              property: long,
              value: style[long]
            }
          });
        }
      }
    }
  }

  return mixed;
}

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function injectStylePrefixed(styles, className, globalPrefix, strict) {
  var outputRules = [];
  var plainBlock = "";

  for (var originalKey in styles) {
    var originalVal = styles[originalKey];

    if (originalVal === void 0 || originalVal === null) {
      continue;
    }

    if (_typeof(originalVal) !== "object") {
      var _prefix;

      // Non-null and non-undefined primitive value
      if (process.env.NODE_ENV !== "production") {
        validateValueType(originalVal, originalKey);
      }

      var propValPair = hyphenateStyleName(originalKey) + ":" + originalVal;
      var prefixed = prefix((_prefix = {}, _prefix[originalKey] = originalVal, _prefix));

      for (var prefixedKey in prefixed) {
        var prefixedVal = prefixed[prefixedKey];

        var prefixedValType = _typeof(prefixedVal);

        if (prefixedValType === "string" || prefixedValType === "number") {
          var prefixedPair = hyphenateStyleName(prefixedKey) + ":" + prefixedVal;

          if (prefixedPair !== propValPair) {
            plainBlock += prefixedPair + ";";
          }
        } else if (Array.isArray(prefixedVal)) {
          var hyphenated = hyphenateStyleName(prefixedKey);

          for (var i = 0; i < prefixedVal.length; i++) {
            var _prefixedPair = hyphenated + ":" + prefixedVal[i];

            if (_prefixedPair !== propValPair) {
              plainBlock += _prefixedPair + ";";
            }
          }
        }
      }

      plainBlock += propValPair + ";";
    } else if (originalKey[0] === ":") {
      outputRules.push("." + globalPrefix + "css-" + className + originalKey + "{" + injectStylePrefixed(originalVal, "", globalPrefix, strict).join("") + "}");
    } else if (originalKey[0] === "@") {
      outputRules.push(originalKey + "{" + injectStylePrefixed(originalVal, className, globalPrefix, strict).join("") + "}");
    } else {
      outputRules.push(originalKey + "{" + injectStylePrefixed(originalVal, "", globalPrefix, strict).join("") + "}");
    }
  } // strict mode checks for mixed long/shorthands to keep compatibility with atomic engine


  if (strict && process.env.NODE_ENV !== "production") {
    var conflicts = validateNoMixedHand(styles);

    if (conflicts.length) {
      conflicts.forEach(function (_ref) {
        var _JSON$stringify, _JSON$stringify2;

        var shorthand = _ref.shorthand,
            longhand = _ref.longhand;
        var short = JSON.stringify((_JSON$stringify = {}, _JSON$stringify[shorthand.property] = shorthand.value, _JSON$stringify));
        var long = JSON.stringify((_JSON$stringify2 = {}, _JSON$stringify2[longhand.property] = longhand.value, _JSON$stringify2)); // eslint-disable-next-line no-console

        console.warn("Styles `" + short + "` and `" + long + "` in object yielding class \"" + className + "\" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.");
      });
    }
  } // we are inside of a pseudo-selector


  if (!className) {
    return [plainBlock];
  }

  if (!plainBlock) {
    return outputRules;
  }

  return ["." + globalPrefix + "css-" + className + "{" + plainBlock + "}"].concat(outputRules);
}

function validateValueType(value, key) {
  if (value === null || Array.isArray(value) || typeof value !== "number" && typeof value !== "string") {
    throw new Error("Unsupported style value: " + JSON.stringify(value) + " used in property " + JSON.stringify(key));
  }
}

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

/* eslint-disable no-console */
var validAnimationState = /^(from|to|\+?(\d*\.)?\d+%)(\s*,\s*(from|to|\+?(\d*\.)?\d+%))*$/;
function validateKeyframesObject(keyframes) {
  var valid = true;

  for (var animationState in keyframes) {
    var value = keyframes[animationState];

    if (!validAnimationState.test(animationState)) {
      valid = false;
      console.warn("Warning: property \"" + animationState + "\" in keyframes object " + JSON.stringify(keyframes) + " is not a valid. Must be \"from\", \"to\", or a percentage.");
    }

    if (_typeof$1(value) !== "object") {
      valid = false;
      console.warn("Warning: value for \"" + animationState + "\" property in keyframes object " + JSON.stringify(keyframes) + " must be an object. Instead it was a " + _typeof$1(value) + ".");
    }

    if (!valid) {
      console.warn("Warning: object used as value for \"animationName\" style is invalid:", keyframes);
    }
  }
}

// vendored in from styled-components
var AD_REPLACER_R = /(a)(d)/gi;
/* This is the "capacity" of our alphabet i.e. 2x26 for all letters plus their capitalised
 * counterparts */

var charsLength = 52;
/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */

var getAlphabeticChar = function getAlphabeticChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
};
/* input a number, usually a hash and convert it to base-52 */


function generateAlphabeticName(code) {
  var name = "";
  var x;
  /* get a char and divide by alphabet-length */

  for (x = Math.abs(code); x > charsLength; x = x / charsLength | 0) {
    name = getAlphabeticChar(x % charsLength) + name;
  }

  return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, "$1-$2");
}

// vendored in from styled-components
var SEED = 5381 | 0; // When we have separate strings it's useful to run a progressive
// version of djb2 where we pretend that we're still looping over
// the same string

var phash = function phash(h, x) {
  h |= 0;

  for (var i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }

  return h;
}; // This is a djb2 hashing function

var hash = function hash(x) {
  return phash(SEED, x) >>> 0;
};

function hashCssObject(cssObject) {
  return generateAlphabeticName(hash(JSON.stringify(cssObject)));
}
function keyframesToBlock(keyframes) {
  if (process.env.NODE_ENV !== "production") {
    validateKeyframesObject(keyframes);
  }

  if (process.env.NODE_ENV !== "production" && typeof Object.getPrototypeOf(keyframes) !== "undefined") {
    if (Object.getPrototypeOf(keyframes) !== Object.getPrototypeOf({})) {
      // eslint-disable-next-line no-console
      console.warn("Only plain objects should be used as animation values. Unexpectedly recieved:", keyframes);
    }
  }

  var result = "";

  for (var animationState in keyframes) {
    result += animationState + "{" + declarationsToBlock(keyframes[animationState]) + "}";
  }

  return result;
}
function declarationsToBlock(style) {
  var css = "";

  for (var prop in style) {
    var val = style[prop];

    if (typeof val === "string" || typeof val === "number") {
      css += hyphenateStyleName(prop) + ":" + val + ";";
    }
  } // trim trailing semicolon


  return css.slice(0, -1);
}
function keyframesBlockToRule(id, block) {
  return "@keyframes " + id + "{" + block + "}";
}
function fontFaceBlockToRule(id, block) {
  return "@font-face{font-family:" + id + ";" + block + "}";
}

/* eslint-env browser */
var StyletronClient =
/*#__PURE__*/
function () {
  function StyletronClient(opts) {
    var _this = this;

    if (opts === void 0) {
      opts = {};
    }

    this.opts = opts || {};
    this.cache = {};

    if (opts.container) {
      this.container = opts.container;
    } // hydration


    if (opts.hydrate && opts.hydrate.length > 1) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn("Client hydration expects only a single style tag from the server. Make sure your server uses styletron-engine-monolithic and not atomic.");
      }
    } else if (opts.hydrate && opts.hydrate.length === 1) {
      // infer container from parent element
      if (!this.container) {
        var parentElement = opts.hydrate[0].parentElement;

        if (parentElement !== null && parentElement !== void 0) {
          this.container = parentElement;
        }
      } // there is a single style tag coming from the monolithic server


      var element = opts.hydrate[0];
      var dataHydrate = element.getAttribute("data-hydrate");

      if (dataHydrate) {
        dataHydrate.split(" ").forEach(function (hashKey) {
          // cache keys are unique across fonts, keyframes and other css so
          // we use a single attribute to get them all
          _this.cache[hashKey] = true;
        });
      }
    }

    if (!this.container) {
      if (document.head === null) {
        throw new Error("No container provided and `document.head` was null");
      }

      this.container = document.head;
    }

    this.styleSheet = new StyleSheet({
      container: this.container
    });
  }

  var _proto = StyletronClient.prototype;

  _proto.renderStyle = function renderStyle(styles) {
    var className = hashCssObject(styles);

    if (!this.cache[className]) {
      this.cache[className] = true;
      this.styleSheet.insert(injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)));
    }

    return (this.opts.prefix || "") + "css-" + className;
  };

  _proto.renderFontFace = function renderFontFace(fontFace) {
    var fontName = hashCssObject(fontFace);

    if (!this.cache[fontName]) {
      this.cache[fontName] = true;
      this.styleSheet.insert([fontFaceBlockToRule((this.opts.prefix || "") + "font-" + fontName, declarationsToBlock(fontFace))]);
    }

    return (this.opts.prefix || "") + "font-" + fontName;
  };

  _proto.renderKeyframes = function renderKeyframes(keyframes) {
    var animationName = hashCssObject(keyframes);

    if (!this.cache[animationName]) {
      this.cache[animationName] = true;
      this.styleSheet.insert([keyframesBlockToRule((this.opts.prefix || "") + "animation-" + animationName, keyframesToBlock(keyframes))]);
    }

    return (this.opts.prefix || "") + "animation-" + animationName;
  };

  return StyletronClient;
}();

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var StyletronServer =
/*#__PURE__*/
function () {
  function StyletronServer(opts) {
    if (opts === void 0) {
      opts = {};
    }

    this.opts = opts || {};
    this.cache = {};
  }

  var _proto = StyletronServer.prototype;

  _proto.renderStyle = function renderStyle(styles) {
    var className = hashCssObject(styles);

    if (!this.cache[className]) {
      this.cache[className] = injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)).join("");
    }

    return (this.opts.prefix || "") + "css-" + className;
  };

  _proto.renderFontFace = function renderFontFace(fontFace) {
    var fontName = hashCssObject(fontFace);

    if (!this.cache[fontName]) {
      this.cache[fontName] = fontFaceBlockToRule((this.opts.prefix || "") + "font-" + fontName, declarationsToBlock(fontFace));
    }

    return (this.opts.prefix || "") + "font-" + fontName;
  };

  _proto.renderKeyframes = function renderKeyframes(keyframes) {
    var animationName = hashCssObject(keyframes);

    if (!this.cache[animationName]) {
      this.cache[animationName] = keyframesBlockToRule((this.opts.prefix || "") + "animation-" + animationName, keyframesToBlock(keyframes));
    }

    return (this.opts.prefix || "") + "animation-" + animationName;
  };

  _proto.getStylesheets = function getStylesheets() {
    var hashedNames = [].concat(Object.keys(this.cache));
    return [{
      css: this.getCss(),
      attrs: {
        "data-hydrate": hashedNames.join(" ")
      }
    }];
  };

  _proto.getStylesheetsHtml = function getStylesheetsHtml(className) {
    if (className === void 0) {
      className = "_styletron_hydrate_";
    }

    return generateHtmlString(this.getStylesheets(), className);
  };

  _proto.getCss = function getCss() {
    return [].concat(Object.values(this.cache)).join("");
  };

  return StyletronServer;
}();

function generateHtmlString(sheets, className) {
  var html = "";

  for (var i = 0; i < sheets.length; i++) {
    var sheet = sheets[i];

    var _sheet$attrs = sheet.attrs,
        originalClassName = _sheet$attrs.class,
        rest = _objectWithoutProperties(_sheet$attrs, ["class"]);

    var attrs = Object.assign({
      class: originalClassName ? className + " " + originalClassName : className
    }, rest);
    html += "<style" + attrsToString(attrs) + ">" + sheet.css + "</style>";
  }

  return html;
}

function attrsToString(attrs) {
  var result = "";

  for (var attr in attrs) {
    var value = attrs[attr];

    if (value === true) {
      result += " " + attr;
    } else if (value !== false) {
      result += " " + attr + "=\"" + value + "\"";
    }
  }

  return result;
}

export { StyletronClient as Client, StyletronServer as Server };
//# sourceMappingURL=browser.es5.es.js.map
