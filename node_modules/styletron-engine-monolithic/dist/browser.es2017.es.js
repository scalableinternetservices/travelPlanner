import { prefix } from 'inline-style-prefixer';

/* eslint-env browser */

/*
pretty much vendored @emotion/sheet
Based off glamor's StyleSheet, thanks Sunil ❤️
high performance StyleSheet for css-in-js systems
- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance
// usage
import { StyleSheet } from '@emotion/sheet'
let styleSheet = new StyleSheet({ container: document.head })
styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet
styleSheet.flush()
- empties the stylesheet of all its contents
*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (let i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  const tag = document.createElement("style");

  if (typeof options.nonce !== "undefined") {
    tag.setAttribute("nonce", options.nonce);
  }

  tag.appendChild(document.createTextNode(""));
  return tag;
}

class StyleSheet {
  constructor(options) {
    this.isSpeedy = typeof options.speedy === "undefined" ? !(process.env.NODE_ENV !== "production") : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.container = options.container;
    this.before = null;
  }

  insert(rules) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      const tag = createStyleElement(this);
      let before;

      if (this.tags.length === 0) {
        before = this.before;
      } else {
        before = this.tags[this.tags.length - 1].nextSibling;
      }

      this.container.insertBefore(tag, before);
      this.tags.push(tag);
    }

    const tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      const sheet = sheetForTag(tag);
      rules.forEach(rule => {
        try {
          // this is the ultrafast version, works across browsers
          // the big drawback is that the css won't be editable in devtools
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
          if (process.env.NODE_ENV !== "production") {
            // eslint-disable-next-line no-console
            console.warn(`There was a problem inserting the following rule: "${rule}"`, e);
          }
        }
      });
    } else {
      tag.appendChild(document.createTextNode(rules.join("")));
    }

    this.ctr++;
  }

  flush() {
    // $FlowFixMe
    this.tags.forEach(tag => tag.parentNode.removeChild(tag));
    this.tags = [];
    this.ctr = 0;
  }

}

const uppercasePattern = /[A-Z]/g;
const msPattern = /^ms-/;
const cache = {};
function hyphenateStyleName(prop) {
  return prop in cache ? cache[prop] : cache[prop] = prop.replace(uppercasePattern, "-$&").toLowerCase().replace(msPattern, "-ms-");
}

/**
 * Adapted from https://github.com/gilmoreorless/css-shorthand-properties
 */
const shorthandMap = {
  // CSS 2.1: https://www.w3.org/TR/CSS2/propidx.html
  "list-style": ["list-style-type", "list-style-position", "list-style-image"],
  margin: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
  outline: ["outline-width", "outline-style", "outline-color"],
  padding: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
  // CSS Backgrounds and Borders Module Level 3: https://www.w3.org/TR/css3-background/
  background: ["background-image", "background-position", "background-size", "background-repeat", "background-origin", "background-clip", "background-attachment", "background-color"],
  border: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width", "border-width", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-style", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-color"],
  "border-color": ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"],
  "border-style": ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"],
  "border-width": ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
  "border-top": ["border-top-width", "border-top-style", "border-top-color"],
  "border-right": ["border-right-width", "border-right-style", "border-right-color"],
  "border-bottom": ["border-bottom-width", "border-bottom-style", "border-bottom-color"],
  "border-left": ["border-left-width", "border-left-style", "border-left-color"],
  "border-radius": ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"],
  "border-image": ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"],
  // CSS Fonts Module Level 3: https://www.w3.org/TR/css3-fonts/
  font: ["font-style", "font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian", "font-variant", "font-weight", "font-stretch", "font-size", "line-height", "font-family"],
  "font-variant": ["font-variant-ligatures", "font-variant-alternates", "font-variant-caps", "font-variant-numeric", "font-variant-east-asian"],
  // CSS Flexible Box Layout Module Level 1: https://www.w3.org/TR/css3-flexbox-1/
  flex: ["flex-grow", "flex-shrink", "flex-basis"],
  "flex-flow": ["flex-direction", "flex-wrap"],
  // CSS Grid Layout Module Level 1: https://www.w3.org/TR/css-grid-1/
  grid: ["grid-template-rows", "grid-template-columns", "grid-template-areas", "grid-auto-rows", "grid-auto-columns", "grid-auto-flow"],
  "grid-template": ["grid-template-rows", "grid-template-columns", "grid-template-areas"],
  "grid-row": ["grid-row-start", "grid-row-end"],
  "grid-column": ["grid-column-start", "grid-column-end"],
  "grid-area": ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end"],
  "grid-gap": ["grid-row-gap", "grid-column-gap"],
  // CSS Masking Module Level 1: https://www.w3.org/TR/css-masking/
  mask: ["mask-image", "mask-mode", "mask-position", "mask-size", "mask-repeat", "mask-origin", "mask-clip"],
  "mask-border": ["mask-border-source", "mask-border-slice", "mask-border-width", "mask-border-outset", "mask-border-repeat", "mask-border-mode"],
  // CSS Multi-column Layout Module: https://www.w3.org/TR/css3-multicol/
  columns: ["column-width", "column-count"],
  "column-rule": ["column-rule-width", "column-rule-style", "column-rule-color"],
  // CSS Scroll Snap Module Level 1: https://www.w3.org/TR/css-scroll-snap-1/
  "scroll-padding": ["scroll-padding-top", "scroll-padding-right", "scroll-padding-bottom", "scroll-padding-left"],
  "scroll-padding-block": ["scroll-padding-block-start", "scroll-padding-block-end"],
  "scroll-padding-inline": ["scroll-padding-inline-start", "scroll-padding-inline-end"],
  "scroll-snap-margin": ["scroll-snap-margin-top", "scroll-snap-margin-right", "scroll-snap-margin-bottom", "scroll-snap-margin-left"],
  "scroll-snap-margin-block": ["scroll-snap-margin-block-start", "scroll-snap-margin-block-end"],
  "scroll-snap-margin-inline": ["scroll-snap-margin-inline-start", "scroll-snap-margin-inline-end"],
  // CSS Speech Module: https://www.w3.org/TR/css3-speech/
  cue: ["cue-before", "cue-after"],
  pause: ["pause-before", "pause-after"],
  rest: ["rest-before", "rest-after"],
  // CSS Text Decoration Module Level 3: https://www.w3.org/TR/css-text-decor-3/
  "text-decoration": ["text-decoration-line", "text-decoration-style", "text-decoration-color"],
  "text-emphasis": ["text-emphasis-style", "text-emphasis-color"],
  // CSS Animations (WD): https://www.w3.org/TR/css3-animations
  animation: ["animation-name", "animation-duration", "animation-timing-function", "animation-delay", "animation-iteration-count", "animation-direction", "animation-fill-mode", "animation-play-state"],
  // CSS Transitions (WD): https://www.w3.org/TR/css3-transitions/
  transition: ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"]
};
function validateNoMixedHand(style) {
  const hyphenatedProperties = Object.keys(style).reduce((acc, property) => {
    acc[hyphenateStyleName(property)] = property;
    return acc;
  }, {});
  const mixed = [];

  for (const property in hyphenatedProperties) {
    if (property in shorthandMap) {
      for (const longhand of shorthandMap[property]) {
        if (longhand in hyphenatedProperties) {
          const long = hyphenatedProperties[longhand];
          const short = hyphenatedProperties[property];
          mixed.push({
            shorthand: {
              property: short,
              value: style[short]
            },
            longhand: {
              property: long,
              value: style[long]
            }
          });
        }
      }
    }
  }

  return mixed;
}

function injectStylePrefixed(styles, className, globalPrefix, strict) {
  const outputRules = [];
  let plainBlock = "";

  for (const originalKey in styles) {
    const originalVal = styles[originalKey];

    if (originalVal === void 0 || originalVal === null) {
      continue;
    }

    if (typeof originalVal !== "object") {
      // Non-null and non-undefined primitive value
      if (process.env.NODE_ENV !== "production") {
        validateValueType(originalVal, originalKey);
      }

      const propValPair = `${hyphenateStyleName(originalKey)}:${originalVal}`;
      const prefixed = prefix({
        [originalKey]: originalVal
      });

      for (const prefixedKey in prefixed) {
        const prefixedVal = prefixed[prefixedKey];
        const prefixedValType = typeof prefixedVal;

        if (prefixedValType === "string" || prefixedValType === "number") {
          const prefixedPair = `${hyphenateStyleName(prefixedKey)}:${prefixedVal}`;

          if (prefixedPair !== propValPair) {
            plainBlock += `${prefixedPair};`;
          }
        } else if (Array.isArray(prefixedVal)) {
          const hyphenated = hyphenateStyleName(prefixedKey);

          for (let i = 0; i < prefixedVal.length; i++) {
            const prefixedPair = `${hyphenated}:${prefixedVal[i]}`;

            if (prefixedPair !== propValPair) {
              plainBlock += `${prefixedPair};`;
            }
          }
        }
      }

      plainBlock += `${propValPair};`;
    } else if (originalKey[0] === ":") {
      outputRules.push(`.${globalPrefix}css-${className}${originalKey}{${injectStylePrefixed(originalVal, "", globalPrefix, strict).join("")}}`);
    } else if (originalKey[0] === "@") {
      outputRules.push(`${originalKey}{${injectStylePrefixed(originalVal, className, globalPrefix, strict).join("")}}`);
    } else {
      outputRules.push(`${originalKey}{${injectStylePrefixed(originalVal, "", globalPrefix, strict).join("")}}`);
    }
  } // strict mode checks for mixed long/shorthands to keep compatibility with atomic engine


  if (strict && process.env.NODE_ENV !== "production") {
    const conflicts = validateNoMixedHand(styles);

    if (conflicts.length) {
      conflicts.forEach(({
        shorthand,
        longhand
      }) => {
        const short = JSON.stringify({
          [shorthand.property]: shorthand.value
        });
        const long = JSON.stringify({
          [longhand.property]: longhand.value
        }); // eslint-disable-next-line no-console

        console.warn(`Styles \`${short}\` and \`${long}\` in object yielding class "${className}" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.`);
      });
    }
  } // we are inside of a pseudo-selector


  if (!className) {
    return [plainBlock];
  }

  if (!plainBlock) {
    return outputRules;
  }

  return [`.${globalPrefix}css-${className}{${plainBlock}}`, ...outputRules];
}

function validateValueType(value, key) {
  if (value === null || Array.isArray(value) || typeof value !== "number" && typeof value !== "string") {
    throw new Error(`Unsupported style value: ${JSON.stringify(value)} used in property ${JSON.stringify(key)}`);
  }
}

/* eslint-disable no-console */
const validAnimationState = /^(from|to|\+?(\d*\.)?\d+%)(\s*,\s*(from|to|\+?(\d*\.)?\d+%))*$/;
function validateKeyframesObject(keyframes) {
  let valid = true;

  for (const animationState in keyframes) {
    const value = keyframes[animationState];

    if (!validAnimationState.test(animationState)) {
      valid = false;
      console.warn(`Warning: property "${animationState}" in keyframes object ${JSON.stringify(keyframes)} is not a valid. Must be "from", "to", or a percentage.`);
    }

    if (typeof value !== "object") {
      valid = false;
      console.warn(`Warning: value for "${animationState}" property in keyframes object ${JSON.stringify(keyframes)} must be an object. Instead it was a ${typeof value}.`);
    }

    if (!valid) {
      console.warn(`Warning: object used as value for "animationName" style is invalid:`, keyframes);
    }
  }
}

// vendored in from styled-components
const AD_REPLACER_R = /(a)(d)/gi;
/* This is the "capacity" of our alphabet i.e. 2x26 for all letters plus their capitalised
 * counterparts */

const charsLength = 52;
/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */

const getAlphabeticChar = code => String.fromCharCode(code + (code > 25 ? 39 : 97));
/* input a number, usually a hash and convert it to base-52 */


function generateAlphabeticName(code) {
  let name = "";
  let x;
  /* get a char and divide by alphabet-length */

  for (x = Math.abs(code); x > charsLength; x = x / charsLength | 0) {
    name = getAlphabeticChar(x % charsLength) + name;
  }

  return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, "$1-$2");
}

// vendored in from styled-components
const SEED = 5381 | 0; // When we have separate strings it's useful to run a progressive
// version of djb2 where we pretend that we're still looping over
// the same string

const phash = (h, x) => {
  h |= 0;

  for (let i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }

  return h;
}; // This is a djb2 hashing function

const hash = x => {
  return phash(SEED, x) >>> 0;
};

function hashCssObject(cssObject) {
  return generateAlphabeticName(hash(JSON.stringify(cssObject)));
}
function keyframesToBlock(keyframes) {
  if (process.env.NODE_ENV !== "production") {
    validateKeyframesObject(keyframes);
  }

  if (process.env.NODE_ENV !== "production" && typeof Object.getPrototypeOf(keyframes) !== "undefined") {
    if (Object.getPrototypeOf(keyframes) !== Object.getPrototypeOf({})) {
      // eslint-disable-next-line no-console
      console.warn("Only plain objects should be used as animation values. Unexpectedly recieved:", keyframes);
    }
  }

  let result = "";

  for (const animationState in keyframes) {
    result += `${animationState}{${declarationsToBlock(keyframes[animationState])}}`;
  }

  return result;
}
function declarationsToBlock(style) {
  let css = "";

  for (const prop in style) {
    const val = style[prop];

    if (typeof val === "string" || typeof val === "number") {
      css += `${hyphenateStyleName(prop)}:${val};`;
    }
  } // trim trailing semicolon


  return css.slice(0, -1);
}
function keyframesBlockToRule(id, block) {
  return `@keyframes ${id}{${block}}`;
}
function fontFaceBlockToRule(id, block) {
  return `@font-face{font-family:${id};${block}}`;
}

/* eslint-env browser */
class StyletronClient {
  constructor(opts = {}) {
    this.opts = opts || {};
    this.cache = {};

    if (opts.container) {
      this.container = opts.container;
    } // hydration


    if (opts.hydrate && opts.hydrate.length > 1) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn("Client hydration expects only a single style tag from the server. Make sure your server uses styletron-engine-monolithic and not atomic.");
      }
    } else if (opts.hydrate && opts.hydrate.length === 1) {
      // infer container from parent element
      if (!this.container) {
        const parentElement = opts.hydrate[0].parentElement;

        if (parentElement !== null && parentElement !== void 0) {
          this.container = parentElement;
        }
      } // there is a single style tag coming from the monolithic server


      const element = opts.hydrate[0];
      const dataHydrate = element.getAttribute("data-hydrate");

      if (dataHydrate) {
        dataHydrate.split(" ").forEach(hashKey => {
          // cache keys are unique across fonts, keyframes and other css so
          // we use a single attribute to get them all
          this.cache[hashKey] = true;
        });
      }
    }

    if (!this.container) {
      if (document.head === null) {
        throw new Error("No container provided and `document.head` was null");
      }

      this.container = document.head;
    }

    this.styleSheet = new StyleSheet({
      container: this.container
    });
  }

  renderStyle(styles) {
    const className = hashCssObject(styles);

    if (!this.cache[className]) {
      this.cache[className] = true;
      this.styleSheet.insert(injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)));
    }

    return `${this.opts.prefix || ""}css-${className}`;
  }

  renderFontFace(fontFace) {
    const fontName = hashCssObject(fontFace);

    if (!this.cache[fontName]) {
      this.cache[fontName] = true;
      this.styleSheet.insert([fontFaceBlockToRule(`${this.opts.prefix || ""}font-${fontName}`, declarationsToBlock(fontFace))]);
    }

    return `${this.opts.prefix || ""}font-${fontName}`;
  }

  renderKeyframes(keyframes) {
    const animationName = hashCssObject(keyframes);

    if (!this.cache[animationName]) {
      this.cache[animationName] = true;
      this.styleSheet.insert([keyframesBlockToRule(`${this.opts.prefix || ""}animation-${animationName}`, keyframesToBlock(keyframes))]);
    }

    return `${this.opts.prefix || ""}animation-${animationName}`;
  }

}

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

class StyletronServer {
  constructor(opts = {}) {
    this.opts = opts || {};
    this.cache = {};
  }

  renderStyle(styles) {
    const className = hashCssObject(styles);

    if (!this.cache[className]) {
      this.cache[className] = injectStylePrefixed(styles, className, this.opts.prefix || "", Boolean(this.opts.strict)).join("");
    }

    return `${this.opts.prefix || ""}css-${className}`;
  }

  renderFontFace(fontFace) {
    const fontName = hashCssObject(fontFace);

    if (!this.cache[fontName]) {
      this.cache[fontName] = fontFaceBlockToRule(`${this.opts.prefix || ""}font-${fontName}`, declarationsToBlock(fontFace));
    }

    return `${this.opts.prefix || ""}font-${fontName}`;
  }

  renderKeyframes(keyframes) {
    const animationName = hashCssObject(keyframes);

    if (!this.cache[animationName]) {
      this.cache[animationName] = keyframesBlockToRule(`${this.opts.prefix || ""}animation-${animationName}`, keyframesToBlock(keyframes));
    }

    return `${this.opts.prefix || ""}animation-${animationName}`;
  }

  getStylesheets() {
    const hashedNames = [...Object.keys(this.cache)];
    return [{
      css: this.getCss(),
      attrs: {
        "data-hydrate": hashedNames.join(" ")
      }
    }];
  }

  getStylesheetsHtml(className = "_styletron_hydrate_") {
    return generateHtmlString(this.getStylesheets(), className);
  }

  getCss() {
    return [...Object.values(this.cache)].join("");
  }

}

function generateHtmlString(sheets, className) {
  let html = "";

  for (let i = 0; i < sheets.length; i++) {
    const sheet = sheets[i];

    const _sheet$attrs = sheet.attrs,
          {
      class: originalClassName
    } = _sheet$attrs,
          rest = _objectWithoutPropertiesLoose(_sheet$attrs, ["class"]);

    const attrs = Object.assign({
      class: originalClassName ? `${className} ${originalClassName}` : className
    }, rest);
    html += `<style${attrsToString(attrs)}>${sheet.css}</style>`;
  }

  return html;
}

function attrsToString(attrs) {
  let result = "";

  for (const attr in attrs) {
    const value = attrs[attr];

    if (value === true) {
      result += " " + attr;
    } else if (value !== false) {
      result += ` ${attr}="${value}"`;
    }
  }

  return result;
}

export { StyletronClient as Client, StyletronServer as Server };
//# sourceMappingURL=browser.es2017.es.js.map
